<script>
    function defaultEquals(a, b) {
        return a === b;
    }
    class Node {
        constructor(element, next) {
            this.element = element;
            this.next = next;
        }
    }

    // - 链表 (Linked list) 书上完整源码
    class LinkedList {
        constructor(equalsFn = defaultEquals) {
            this.equalsFn = equalsFn;
            this.count = 0;
            this.head = undefined;
        }

        // - push(element): 向链表尾部添加一个新元素.
        push(element) {
            const node = new Node(element); // {1}
            // - current: 指向链表中 current (当前) 项的变量.
            let current;    // {2}
            if (this.head == null) {    // {3}
                // catches null && undefined
                // - 把要添加的 node (节点实例) 赋值给 head.
                this.head = node;
            } else {
                // - Note: 当第 2 次调用 push() 方法时 this.head 已经是一个
                //   Node 构造函数的实例, 输出为:
                //   `Node {element: 15, next: undefined}`
                current = this.head;
                while (current.next != null) {
                    current = current.next;
                }
                current.next = node;
                console.log(current);
            }
            this.count++;
        }

        // - getElementAt(index): 返回链表中特定位置的元素. 如果链表中不存在这样的
        //   元素, 则返回 undefined.
        getElementAt(index) {
            if (index >= 0 && index <= this.count) {
                let node = this.head;
                for (let i = 0; i < index && node != null; i++) {
                    node = node.next;
                }
                return node;
            }
            return undefined;
        }

        // - insert(element, index): 向链表的特定位置插入一个新元素.
        insert(element, index) {
            if (index >= 0 && index <= this.count) {
                const node = new Node(element);
                // - 第 1 种场景是需要在链表的起点添加一个元素, 也就是第一个位置.
                if (index === 0) {
                    node.next = this.head;
                    this.head = node;
                }
                // - 第 2 种场景在链表中间或尾部添加一个元素.
                else {
                    // - (index-1) 表示需要添加新节点位置的前一个位置.
                    const previous = this.getElementAt(index - 1);
                    node.next = previous.next;
                    previous.next = node;
                }
                this.count++;
                return true;
            }
            return false;
        }
        removeAt(index) {
            if (index >= 0 && index < this.count) {
                let current = this.head;
                if (index === 0) {
                    this.head = current.next;
                } else {
                    const previous = this.getElementAt(index - 1);
                    current = previous.next;
                    // - 把当前的下一项(current.next), 赋值给上一项的下一项
                    //   (previous.next) 也即是赋值给当前项(current), 那么当前项
                    //   就被替覆盖了.
                    previous.next = current.next;
                }
                this.count--;
                return current.element;
            }
            return undefined;
        }

        // - remove(element): 从链表中移除一个元素
        remove(element) {
            const index = this.indexOf(element);
            return this.removeAt(index);
        }

        // - indexOf(element): 返回元素在链表中的索引. 如果链表中没有该元素则返回 -1.
        indexOf(element) {
            let current = this.head;
            for (let i = 0; i < this.size() && current != null; i++) {
                if (this.equalsFn(element, current.element)) {
                    return i;
                }
                current = current.next;
            }
            return -1;
        }
        isEmpty() {return this.size() === 0;}
        size() {return this.count;}
        getHead() {return this.head;}
        clear() {
            this.head = undefined;
            this.count = 0;
        }
        toString() {
            if (this.head == null) {
                return '';
            }
            let objString = `${this.head.element}`;
            let current = this.head.next;
            for (let i = 1; i < this.size() && current != null; i++) {
                objString = `${objString},${current.element}`;
                current = current.next;
            }
            return objString;
        }
    }

    const list = new LinkedList();
    list.push(15);
    list.push(10);
    list.push(5);
    list.push(6);
    list.push(9);

    console.log(list.removeAt(3));

    // console.log("list:");
    // console.log(list);
    // console.log(list.toString());


</script>