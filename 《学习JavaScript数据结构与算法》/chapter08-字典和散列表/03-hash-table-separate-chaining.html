<script>
    // - chapter06-链表的代码 (复用)
    function defaultEquals(a, b) {
        return a === b;
    }
    class Node {
        constructor(element, next) {
            this.element = element;
            this.next = next;
        }
    }

    class LinkedList {
        constructor(equalsFn = defaultEquals) {
            this.equalsFn = equalsFn;
            this.count = 0;
            this.head = undefined;
        }

        push(element) {
            const node = new Node(element); // {1}
            let current;    // {2}
            if (this.head == null) {    // {3}
                this.head = node;
            } else {
                current = this.head;
                while (current.next != null) {
                    current = current.next;
                }
                current.next = node;
                // console.log(current);
            }
            this.count++;
        }

        getElementAt(index) {
            if (index >= 0 && index <= this.count) {
                let node = this.head;
                for (let i = 0; i < index && node != null; i++) {
                    node = node.next;
                }
                return node;
            }
            return undefined;
        }

        // - insert(element, index): 向链表的特定位置插入一个新元素.
        insert(element, index) {
            if (index >= 0 && index <= this.count) {
                const node = new Node(element);
                if (index === 0) {
                    node.next = this.head;
                    this.head = node;
                }
                else {
                    const previous = this.getElementAt(index - 1);
                    node.next = previous.next;
                    previous.next = node;
                }
                this.count++;
                return true;
            }
            return false;
        }
        removeAt(index) {
            if (index >= 0 && index < this.count) {
                let current = this.head;
                if (index === 0) {
                    this.head = current.next;
                } else {
                    const previous = this.getElementAt(index - 1);
                    current = previous.next;
                    previous.next = current.next;
                }
                this.count--;
                return current.element;
            }
            return undefined;
        }

        // - remove(element): 从链表中移除一个元素
        remove(element) {
            const index = this.indexOf(element);
            return this.removeAt(index);
        }

        // - indexOf(element): 返回元素在链表中的索引. 如果链表中没有该元素则返回 -1.
        indexOf(element) {
            let current = this.head;
            for (let i = 0; i < this.size() && current != null; i++) {
                if (this.equalsFn(element, current.element)) {
                    return i;
                }
                current = current.next;
            }
            return -1;
        }

        isEmpty() {
            return this.size() === 0;
        }
        size() {
            return this.count;
        }
        getHead() {
            return this.head;
        }
        clear() {
            this.head = undefined;
            this.count = 0;
        }
    }


    function defaultToString(item) {
        if (item === null) {
            return 'NULL';
        }
        if (item === undefined) {
            return 'UNDEFINED';
        }
        if (typeof item === 'string' || item instanceof String) {
            return `${item}`;
        }
        return item.toString();
    }
    class ValuePair {
        constructor(key, value) {
            this.key = key;
            this.value = value;
        }
        toString() {
            return `[#${this.key}: ${this.value}]`;
        }
    }


    class HashTableSeparateChaining {
        constructor(toStrFn = defaultToString) {
            this.toStrFn = toStrFn;
            this.table = {};
        }

        loseloseHashCode(key) {
            if (typeof key === 'number') {return key;}
            const tableKey = this.toStrFn(key);
            let hash = 0;
            for (let i = 0; i < tableKey.length; i++) {
                hash += tableKey.charCodeAt(i);
            }
            return hash % 37;
        }

        hashCode(key) {
            return this.loseloseHashCode(key);
        }

        put(key, value) {
           if (key != null && value != null) {
               const position = this.hashCode(key);
               // - 当第一次调用 this.table[position] 时为空, 所以把 new LinkedList()
               //   实例赋值给它
               if (this.table[position] == null) {
                   this.table[position] = new LinkedList();
               }
               // - push() 为 LinkedList 链表方法
               this.table[position].push(new ValuePair(key, value));
               console.log(this.table);
               return true;
           }
           return false;
        }

        get(key) {
            const position = this.hashCode(key);
            const linkedList = this.table[position];
            if (linkedList != null && !linkedList.isEmpty()) {
                let current = linkedList.getHead();
                while (current != null) {
                    if (current.element.key === key) {
                        return current.element.value;
                    }
                    current = current.next;
                }
            }
            return undefined;
        }

        remove(key) {
            const position = this.hashCode(key);
            const linkedList = this.table[position];
            if (linkedList != null && !linkedList.isEmpty()) {
                let current = linkedList.getHead();
                while (current != null) {
                    if (current.element.key === key) {
                        linkedList.remove(current.element);
                        if (linkedList.isEmpty()) {
                            delete this.table[position];
                        }
                        return true;
                    }
                    current = current.next;
                }
            }
            return false;
        }
    }

    const hash = new HashTableSeparateChaining();
    hash.put('Ygritte', 'ygritte@email.com');
    hash.put('Jonathan', 'jonathan@email.com');
    hash.put('Jamie', 'jamie@email.com');
    hash.put('Jack', 'jack@email.com');
    hash.put('Jasmine', 'jasmine@email.com');
    hash.put('Jake', 'jake@email.com');
    hash.put('Nathan', 'nathan@email.com');
    hash.put('Athelstan', 'athelstan@email.com');
    hash.put('Sue', 'sue@email.com');
    hash.put('Aethelwulf', 'aethelwulf@email.com');
    hash.put('Sargeras', 'sargeras@email.com');
    console.log(hash.table);
</script>