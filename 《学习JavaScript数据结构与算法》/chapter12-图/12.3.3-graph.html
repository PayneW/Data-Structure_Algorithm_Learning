<script>
    function defaultToString(item) {
        if (item === null) {
            return 'NULL';
        } if (item === undefined) {
            return 'UNDEFINED';
        } if (typeof item === 'string' || item instanceof String) {
            return `${item}`;
        }
        return item.toString(); // {1}
    }

    class ValuePair {
        constructor(key, value) {
            this.key = key;
            this.value = value;
        }
        toString() {
            return `[#${this.key}: ${this.value}]`;
        }
    }

    class Dictionary {
        constructor(toStrFn = defaultToString) {
            this.toStrFn = toStrFn;
            this.table = {};
        }

        set(key, value) {
            if (key != null && value != null) {
                const tableKey = this.toStrFn(key);
                this.table[tableKey] = new ValuePair(key, value);

                // Output:
                // ValuePair {key: "Gandalf", value: "gandalf@email.com"}
                // ValuePair {key: "John", value: "johnsnow@email.com"}
                // ValuePair {key: "Tyrion", value: "tyrion@email.com"}
                // console.log(this.table[tableKey]);

                // Output:
                // Gandalf: ValuePair {key: "Gandalf", value: "gandalf@email.com"},
                // John: ValuePair {key: "John", value: "johnsnow@email.com"},
                // Tyrion: ValuePair {key: "Tyrion", value: "tyrion@email.com"}
                console.log(this.table);

                return true;
            }
            return false;
        }

        get(key) {
            const valuePair = this.table[this.toStrFn(key)];
            return valuePair == null ? undefined : valuePair.value;
        }

        hasKey(key) {
            return this.table[this.toStrFn(key)] != null;
        }

        remove(key) {
            if (this.hasKey(key)) {
                delete this.table[this.toStrFn(key)];
                return true;
            }
            return false;
        }

        values() {
            return this.keyValues().map(valuePair => valuePair.value);
        }

        keys() {
            return this.keyValues().map(valuePair => valuePair.key);
        }

        keyValues() {
            return Object.values(this.table);
        }

        forEach(callbackFn) {
            const valuePairs = this.keyValues();
            for (let i = 0; i < valuePairs.length; i++) {
                const result = callbackFn(valuePairs[i].key, valuePairs[i].value);
                if (result === false) {
                    break;
                }
            }
        }

        isEmpty() {
            return this.size() === 0;
        }

        size() {
            return Object.keys(this.table).length;
        }

        clear() {
            this.table = {};
        }

        toString() {
            if (this.isEmpty()) {
                return '';
            }
            const valuePairs = this.keyValues();
            let objString = `${valuePairs[0].toString()}`;
            for (let i = 1; i < valuePairs.length; i++) {
                objString = `${objString},${valuePairs[i].toString()}`;
            }
            return objString;
        }
    }

    // - Graph 类
    class Graph {
        constructor(isDirected = false) {
            this.isDirected = isDirected;
            this.vertices = [];
            // - adjacent [ə'dʒeɪs(ə)nt] --adj.相邻的, 邻边的
            // - adjacent list 邻边
            this.adjList = new Dictionary();
        }
        // - 添加顶点 Vertex
        addVertex() {
            if (!this.vertices.includes(v)) {
                this.vertices.push(v);
                this.adjList.set(v, []);
            }
        }
        // - 添加边 edge/adjacent
        addEdge(a, b) {
            if (!this.adjList.get(a)) {
                this.addVertex(a);
            }
            if (!this.adjList.get(b)) {
                this.addVertex(b);
            }
            this.adjList.get(a).push(b);
            if (this.isDirected !== true) {
                this.adjList.get(b).push(a);
            }
        }
        // - 取得顶点
        getVertices() {
            return this.vertices;
        }
        // - 取得邻边
        getAdjList() {
            return this.adjList;
        }
        // - 字符串化, 以便在控制台输出图.
        toString() {
            let s = "";
            for (let i = 0; i < this.vertices.length; i++) {
                s += `${this.vertices[i]} -> `;
                const neighbors = this.adjList.get(this.vertices[i]);
                for (let j = 0; j < neighbors.length; j++) {
                    s += `${neighbors[j]}`;
                }
                s += "\n";
            }
            return s;
        }
    }

    const graph = new Graph();
    const myVertices = ["A", "B", "C", "D", "E", "F", "G", "H", "I",];
    for (let i = 0; i < myVertices.length; i++) {
        graph.addVertex(myVertices[i]);
    }
    graph.addEdge("A", "B");
    graph.addEdge("A", "C");
    graph.addEdge("A", "D");
    graph.addEdge("C", "D");
    graph.addEdge("C", "G");
    graph.addEdge("D", "G");
    graph.addEdge("D", "H");
    graph.addEdge("B", "E");
    graph.addEdge("B", "F");
    graph.addEdge("E", "I");
</script>