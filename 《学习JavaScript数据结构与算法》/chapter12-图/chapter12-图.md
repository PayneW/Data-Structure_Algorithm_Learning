# 第 12 章 -- 图 (Graph)

## 本章目录 (Catalog)
- 12.1 图的相关术语
    + 有向图和无向图
- 12.2 图的表示
    + 12.2.1 邻接矩阵
    + 12.2.2 邻接表
    + 12.2.3 关联矩阵
- 12.3 创建 Graph 类
- 12.4 图的遍历
    + 12.4.1 广度优先搜索
    + 12.4.2 深度优先搜索
- 12.5 最短路径算法
    + 12.5.1 Dijkstra 算法
    + 12.5.2 Floyed-Warshall 算法
- 12.6 最小生成树
    + 12.6.1 Prim 算法
    + 12.6.2 Kruskal 算法
- 12.7 小结        



## 生词 (New Words)
- **vertex ['vɜːteks] --n.顶点; 头顶**
    + the vertex of a mountain. 山峰.
    + vertex angle 顶角
- **direct [dɪ'rekt] --adj.直接的, 正面的. --vt&vi.指导, 指挥, 导向**
    + directed graph 有向图
    + a direct way to the station. 直往火车站的路 [最近的路]
    + I have directed him wrongly. 我给他指错了路.    
- weighted graph. 加权图
- **vertices ['vɜːtɪsiːz] --n.顶点, 头顶, 极点 (vertex 的复数)**
    + merge vertices. 合并顶点
- **adjacent [ə'dʒeɪs(ə)nt] --adj.相邻的, 邻边的** 
    + adjacent list 相邻列表
- **adjacency [ə'dʒeɪsənsɪ] --n.邻接, 邻近**
- **matrix ['meɪtrɪks] --n.矩阵，模型**
    + augmented matrix 增广矩阵
    + correlation matrix 相关矩阵
    + determinant of a matrix 矩阵的行列式
- **incidence ['ɪnsɪd(ə)ns] --n.发生率, 影响范围**
    + decrease the incidence of a disease. 减少某疾病的发病率.


## 本章内容 (Contents)
- 在本章你讲学习另一种非线性数据结构 -- 图. 这也是我们要讲的最后一种数据结构, 下一章将
  深入学习排序和搜索算法.
### 12.1 图的相关术语
- 图是网络结构的抽象模型. 图是一组由**边**连接的**节点**(或顶点). 学习图是重要的, 
  因为任何二元关系都可以用图来表示.
- 任何社交网络, 例如 Facebook, Twitter 和 Google+ 都可以用图来表示.  
  我们还可以用图来表示道路, 航班以及通信.  
- 一个图 $\color{#e7691e}{G = (V, E)}$ 由以下元素组成: $\quad$(其中, G 表示一个图)
    + $V$: 一组顶点. (V 是图 G 中顶点的集合)
    + $E$: 一组边, 链接 $V$ 中的顶点. (E 是图 G 中边的集合)
    + Added from Internet: 
        - 线性表中我们把数据元素叫元素, 树中将数据元素叫节点, 在图中数据元素, 我们则
          称之为顶点 (Vertex).
- 下图表示一个图:  
  <img src="./chapter12-images/graph01.png" style="width:60%;">
    + 在着手实现算法之前, 让我们先了解一下图的一些术语.
    + `由一条边连接在一起的两个顶点称为`**`相邻顶点`**. 比如，A 和 B 是相邻的，
      A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的
    + `一个顶点的`**`度`**`是其相邻顶点的数量`. 比如，A 和其他三个顶点相连接， 
      因此 A 的度为 3; E 和其他两个顶点相连，因此 E 的度为 2.
    + **`路径`**是顶点 $v_1, v_2, \cdots, v_k$ 的一个连续序列, 其中 $v_i$ 和 
      $v_{i+1}$ 是相邻的. 以上一示意图中的图为例，其中包含路径 ABEI 和 ACDG。
    + 简单路径要求不包含重复的顶点. 举个例子, ADG 是一条简单路径. 除去最后一个顶点
      (因为它和第一个顶点是同一个顶点 {Tip: 这里所说的最后一个顶点应该是 A}); 
      **`环`**也是一个简单路径, 比如 ADCA (最后一个顶点重新回到 A).
    + 如果图中不存在环, 则称该图是**`无环的`**. 如果图中每 2 个顶点间都存在路径, 
      则该图是 **`连通的`**. 
#### 12.1.1 有向图和无向图
- 图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向.  
  <img src="./chapter12-images/directed-graph.png" style="width:60%;">
- 如果图中每 2 个顶点间在双向上都存在路径, 则该图是 **`强连通的`**. 例如, C 和 D 是
  强连通的, 而 A 和 B 不是强连通的.
- 图还可以是**未加权的**(目前为止我们看到的图都是未加权的) 或是 **加权的**. 如下图所示,
  加权图的边被赋予了权值.  
  <img src="./chapter12-images/weighted-graph.png" style="width:60%;">
- 我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边
  , 寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径，以及环检测。

### 12.2 图的表示方法
- 从数据结构的角度来说, 我们有多种方式来表示图. 在所有的表示法中, 不存在绝对正确的方式.
  图的正确表示法取决于待解决的问题和图的类型.
#### 12.2.1 邻接矩阵 (adjacency matrix)
- Note: Wikipedia -- 邻接矩阵是图的常用存储表示. 它用 2 个数组分别存储数据元素(顶点)
  的信息 和 数据元素之间的关系 (边 或 弧) 的信息.
- 图最常见的实现是 **邻接矩阵**. 每个节点都和一个整数相关联, 该整数将作为数组的索引.
  我们用一个二维数组来表示顶点之间的连接. 如果索引为 i 的节点和索引为 j 的节点相邻,
  则 `array[i][j] === 1`, 否则 `array[i][j] === 0`, 如下图所示.
  <img src="./chapter12-images/adjacency-matrix.png" style="width:60%;">  
  不是强联通的图 (**稀疏图**) 如果用邻接矩阵来表示, 则矩阵中将会有很多 0, 这意味着我们
  浪费了计算机存储空间来表示根本不存在的边. 例如, 找给定顶点的相邻顶点, 即使该顶点只有一个
  相邻顶点, 我们也不得不迭代一整行. 邻接矩阵表示法不够好的另一个理由是, 图中顶点的数量
  可能会改变, 而二维数组不太灵活.
#### 12.2.2 邻接表 (adjacency list)
- 我们也可以使用一种叫作邻接表的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶点列表
  所组成。存在好几种方式来表示这种数据结构。我们可以用 **列表(数组)**、**链表**，甚至是
  **散列表** 或是 **字典** 来表示相邻顶点列表。下面的示意图展示了邻接表数据结构.  
  <img src="./chapter12-images/adjacency-list.png" style="width:60%;">  
  尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有着不同的
  性质（例如，要找出顶点 v 和 w 是否相邻，使用邻接矩阵会比较快）。在本书的示例中，我们
  将会使用邻接表表示法。
#### 12.2.3 关联矩阵 (incidence matrix)
- 参考文章: [关联矩阵和图](https://zhuanlan.zhihu.com/p/62702660)
- 还可以用关联矩阵来表示图. 在关联矩阵中, 矩阵的行表示顶点, 列表示边. 如下图所示, 使用
  二维数组来表示 2 者之间的连通性, 如果顶点 $v$ 是边 $e$ 的入射点, 则 
  `array[v][e] === 1` 否则, `array[v][e] === 0`.
  <img src="./chapter12-images/incidence-matrix.png" style="width:60%;">  
  关联矩阵通常用于边的数量比顶点多的情况, 以节省空间和内存.

### 12.3 创建 Graph 类

### 12.4 图的遍历
#### 12.4.1 广度优先搜索
#### 12.4.2 深度优先搜索

### 12.5 最短路径算法
#### 12.5.1 Dijkstra 算法
#### 12.5.2 Floyed-Warshall 算法

### 12.6 最小生成树
#### 12.6.1 Prim 算法
#### 12.6.2 Kruskal 算法

### 12.7 小结     

