# 求最大公约数算法


## Catalog
0. 前置知识 `辗转相除法` 和 `更相减损术` -- 来自高中数学必须 3
1. 使用 JavScript 实现求最大公约数算法


## New Words
- **divisor [dɪ'vaɪzɚ] --n.除数; 因数; 因子**
    + Greatest common divisor. 最大公约数
    + In 4 divided by 2, the number 2 is the divisor and
      4 is the dividend. 在 4 被 2 除中, 2 是除数, 4 是被除数.



## Content

### 0. 前置知识 `辗转相除法` 和 `更相减损术` -- 来自高中数学必须 3
- 在小学, 我们学过求 *两个正整数的最大公约数* 的方法: 先用两个数公有的质因数连续去除,
  一直除到所得的商是互质数为止, 例如:

  <img src="./algorithm-blog/1.3-1.png"
        style="margin-left: 0; border-radius: 4px; width: 36%;
            box-shadow: 1px 1px 3px 2px #e5e5e5">
  
- 但是, 当两个数公有的质因数较大时(如 8251 与 6105),
  使用上述方法求最大公约数就比较困难. 下面介绍 2 种古老而有效的算法: 
    + **(1) `辗转相除法`**
      这种算法是由欧几里得在公元前 300 年左右首先提出的, 因而又叫 `欧几里得算法`.

      **Added 辗转相除法的定理: 两个正整数 `a` 和 `b` (a > b),
      它们的最大公约数等于 `a` 除以 `b` 的余数 `c` 和 ` b` 之间的最大公约数.** 
    
      例如: 求 10 和 25 之间的最大公约数 -- A: 25 除以 10 商 2 余 5, 那么 10 
      和 25 的最大公约数等同于 10 和 5 的最大公约数, 即 5.

      例如, 用辗转相除法求 `8251` 与 `6105` 的最大公约数,
      我们可以考虑用两数中较大的数除以较小的数, 求得商和余数:
      $$
        8251 = 6105 \times 1 + 2146.
      $$
      由此可得, 6105 与 2146 的公约数也是 8251 与 6105 的公约数, 反过来,
      8251 与 6105 的公约数也是 6105 与 2146 的公约数, 所以它们的最大公约数相等.
      
      对 6105 与 2146 重复上述步骤
      $$
        6105 = 2146 \times 2 + 1813.
      $$
      同理, 2146 与 1813 的最大公约数也是 6105 与 2146 的最大公约数.
      继续重复上述步骤:
      $$
        2146 = 1813 \times 1 + 33  \\
        1813 = 333 \times 5 + 148, \\ 
        333 = 148 \times 2 + 37,   \\
        148 = 37 \times 4.
      $$
      最后的除数 37 是 148 和 37 的最大公约数, 也就是 8251 与 6105
      的最大公约数这就是辗转相除法. 由除法的性质可以知道, 对于任意两个正整数,
      上述除法步骤总可以在有限步之后完成,
      从而总可以用辗转相除法求出两个正整数的最大公约数.
    + **(2) `更相减损术`**
      `《九章算术》` 是中国古代的数学专著, 其中的 `更相减损术` 也可以用来求 2
      个数的最大公约数, 即 "可半者半之, 不可半者, 副置分母, 子之数, 以少减多,
      更相减损, 求其等也, 以等数约之."
      
      翻译为现在语言如下:
        - 第 (1) 步: 任意给定 2 个正整数, 判断他们是否都是偶数, 若是, 用 2 约减;
          若不是, 执行第 (2) 步.
        - 第 (2) 步: 以较大的数减去较小的数, 接着把所得的差与较小的数比较,
          并以大数减小数. 继续这个操作, 直到所得的数相等为止, 则这个数(等数)
          或这个数与约简的数的乘积就是所求的最大公约数.
      
      下面我们用一个例子来说明这个算法.

      例(1): 用 `更相减损术` 求 98 与 63 的最大公约数. <br>
      解: 由于 63 不是偶数, 把 98 和 63 以大数减小数, 并辗转相间, 如下所示:
      $$
        98 - 63 = 35  \\
        63 - 35 = 28  \\
        35 - 28 = 7   \\
        28 - 7 = 21   \\
        21 - 7 = 14   \\
        14 - 7 = 7    \\
      $$
      所以, 98 与 63 的最大公约数等于 7.


### 1. 使用 JavScript 实现求最大公约数算法
$\quad$根据前置知识中的讲解, 我们该怎么用代码实现一个最大公约数算法呢?
- (1.1) 我们先来看最笨的 "用两个数公有的质因数连续去除,
  一直除到所得的商是互质数为止(即: 上图)" 的方法如何用代码来实现.
  我们先来给出代码, 然后解说一下实现原理:
  ```js
    // - greatest common divisor 最大公约数
    function gcd(a, b) {
        const bigger = a > b ? a : b;           // {1-1}
        const smaller = a < b ? a : b;          // {1-2}
        if (bigger % smaller === 0) {           // {1-3}
            return smaller;
        }
        let divisor = 1;                        // {1-4}
        let i = 2;                              // {1-5}
        let length = smaller / 2;               // {1-6}
        for (; i <= length; i++) {              // {1-7}
            if (a % i === 0 && b % i === 0) {   // {1-8}
                divisor = i;                    // {1-9}
            }
        }
        return divisor;
    } 

    console.log('gcd(18, 30):', gcd(18, 30));   // 6
    console.log('gcd(8251, 6105):', gcd(8251, 6105)); // 37
  ```
  代码分析: 
    + `行{1-1}` 和 `行{1-2}` 先判断传入的数 a, b 谁大谁小;
    + `行{1-3}` 首先做一个判断, 如果大数(bigger)是小数(smaller) 的倍数,
      那直接返回 smaller 即可. 比如: "9 和 27" 或 "8 和 64"
      它们的最大公因数皆为两数中较小的一个.
    + `行{1-4}` 初始化一个变量 divisor(因数) 用于保存将来函数返回的最大公约数;
    + `行{1-5}` 声明 for 循环需要的索引值 i, 两个数的最大公因数不会小于 1,
      因此初始化 i = 2.
    + `行{1-6}` 我们把较小数值大小的一半设置为 for 语句的执行次数. ("Hint:"
      这里为什么设置为较小数值的一半仍不理解, 路过的小伙伴, 明白的可以告知俺, 谢谢.)
    + `行{1-7}`, `行{1-8}`, `行{1-9}` 使用暴力枚举的方法,
      试图寻找到一个合适的整数 i, 看看这个整数能否被 a 和 b 同时整除.
      这个整数 i 从 2 开始循环累加, 一直累加到 a 和 b 中较小参数的一半位置.
      循环结束后, 上一次(即循环结束的前一次)寻找到的能被两个整数整除的最大 i 值,
      就是两数的最大公约数.
        - **Added:** 这里可能会有小伙伴问为什么 i 就成了最小公约数了?
          我把文章的第一张图稍微转换一下, 你便会明白:
          ```
             2 |  18   30                6 |  18   30
               -----------                 -----------
               3 | 9   15                      3   5
                 ---------
                   3    5
          ```
          2 x 3 = 6, 是不是和第二个直接使用 6 的结果是一样的? 
  
  到这里, 第一种最笨求两数的最大公约数算法是完成了, 但是在工作环境中,
  这个算法的效率却不行, 想想看, 比如我传入 gcd(10000, 10001), 用这个方法需要循环
  10000 / 2 - 1 = 4999 次!  如果更大的数, 效率可想而知了......

- (1.2) `辗转相除法`
  
  接下来第二种方法是前置知识中的 `欧几里得算法`,
  此算法大大缩小了求两数的最小公约数的计算次数, 根据前置知识的讲解,
  此处先给出代码实现:
  ```js
    function gcd(a, b) {
        // - 辗转相除法
        // - 给出 (8251, 6105) 辗转相除法的步骤作为下面代码的参考: 
        //   8251 = 6105 x 1 + 2146.
        //   6105 = 2146 x 2 + 1813.
        //   2146 = 1813 x 1 + 33 
        //   1813 = 333 x 5 + 148
        //   333 = 148 x 2 + 37  
        //   148 = 37 x 4.
        function gcd (a, b) {
            let result = 1;             // {2-1}
            if (a > b) {                // {2-2}
                result = divide(a, b)   // {2-3}
            }
            else {
                result = divide(b, a)   // {2-4}
            }
            return result;
        }
        function divide(a, b) {         // {2-5}
            if (a % b === 0) {          // {2-6}
                return b;               // {2-7}
            }
            else {
                return gcd(b, a%b)      // {2-8}
            }
        }
        console.log('gcd(8251, 6105):', gcd(8251, 6105)); // 37
    }
  ```
  代码分析:
    

- (1.3) 最后我们来看 `更相减损术` 方法的代码实现:
  ```js

  ```
  首先我们需要排除 `辗转相除法`, 因为当 2 个数很大时, 对 $a % b$
  的求模运算的性能会比较低. 所以我们改为使用 `更相减损术`.

  我们根据上面对 `更相减损术` 的定义 (1) : 先判断给定的 2 个数是不是都是 `偶数`,
  如果是先用 2 约减. 那么现在就面临第一个问题.

  如何在编程语言实现判断一个数是 奇数 还是 偶数 ?

  A: 在编程中一般有 2 种方式判断一个数是不是偶数.
    + (1) 使用 `按位与(&)` 操作符.  JS 代码如下:
    ```js
        // - 在 JS 中可以使用 `按位与(&)`. 判断一个数字是奇数还是偶数
        // - `按位与(&)`: 按位与操作只在两个数值的对应位都是 1 时才返回 1,
        //   任何一位是 0, 结果都是 0.
        function isEven(num) {
            console.log('num & 1:', num & 1);
            // - 如果传入的 num 为偶数, 执行 num & 1 === 0, 你可能会好奇,
            //   为什么这里不直接写 `if (num & 1 === 0) {return true}`,
            //   实际上我确实试了, 但是被 JS 的隐式转换坑了. if 语句的判断条件
            //   (即 condition), 可以是任意表达式,
            //   如果对这个表达式求值的结果不是布尔值, ES 会自动调用 Boolean()
            //   转换函数将这个表达式的结果转换成布尔值. Boolean(0) = false.
            if (num & 1 === 1) {
                return false;
            }
            return true;
        }
        console.log(isEven(6));     // true
        console.log(isEven(7));     // false
        console.log("Boolean(0):", Boolean(0));     // false
    ```
    + (2) 求余数(%). 求余数的写法是平时使用最多的:
    ```js
        function isEven(num) {
            if (num % 2 === 0) {
                return true
            }
            return false;
        }
    ```